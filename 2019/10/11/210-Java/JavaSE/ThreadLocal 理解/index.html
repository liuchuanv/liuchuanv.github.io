<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>静言思之</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/lib/github-markdown-css/github-markdown.css">
</head>
<body>
<div class="container">
<header class="header">
    <div class="blog-title">
        <a href="/" class="logo">静言思之</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">首页</a>
                </li>
            
                <li class="menu-item">
                    <a href="/archives" class="menu-item-link">归档</a>
                </li>
            
                <li class="menu-item">
                    <a href="https://github.com/ahonn" target="_blank" rel="noopener" class="menu-item-link">交友</a>
                </li>
            
        </ul>
    </nav>
</header>
<main class="main">
    <article class="post">
    <div class="post-title">
        <h2 class="title">ThreadLocal 理解</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2019-10-11</span>
    </div>
    <div class="markdown-body">
        <h3 id="Thread-变量-threadLocals"><a href="#Thread-变量-threadLocals" class="headerlink" title="Thread 变量 threadLocals"></a>Thread 变量 threadLocals</h3><p>线程类Thread内部有一个名为<code>threadLocals</code> 的 <code>ThreadLocal.ThreadLocalMap</code> 变量，它定义如下：</p>
<pre><code class="java">/* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */
    ThreadLocal.ThreadLocalMap threadLocals = null;</code></pre>
<h3 id="ThreadLocal-ThreadLocalMap"><a href="#ThreadLocal-ThreadLocalMap" class="headerlink" title="ThreadLocal.ThreadLocalMap"></a>ThreadLocal.ThreadLocalMap</h3><p><code>ThreadLocal.ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的内部类</p>
<pre><code class="java">    /**
     * ThreadLocalMap is a customized hash map suitable only for
     * maintaining thread local values. No operations are exported
     * outside of the ThreadLocal class. The class is package private to
     * allow declaration of fields in class Thread.  To help deal with
     * very large and long-lived usages, the hash table entries use
     * WeakReferences for keys. However, since reference queues are not
     * used, stale entries are guaranteed to be removed only when
     * the table starts running out of space.
     */
    static class ThreadLocalMap {
        // ...
    }</code></pre>
<p>看注释的第一句话 <code>ThreadLocalMap is a customized hash map suitable only for maintaining thread local values.</code> 意思是 ThreadLocalMap 是一个自定义 HashMap，只适用于线程局部变量。完全可以把它看做是一个 HashMap。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><pre><code class="java">/**
 * This class provides thread-local variables.  These variables differ from
 * their normal counterparts in that each thread that accesses one (via its
 * {@code get} or {@code set} method) has its own, independently initialized
 * copy of the variable.  {@code ThreadLocal} instances are typically private
 * static fields in classes that wish to associate state with a thread (e.g.,
 * a user ID or Transaction ID).
 *
 * &lt;p&gt;For example, the class below generates unique identifiers local to each
 * thread.
 * A thread&#39;s id is assigned the first time it invokes {@code ThreadId.get()}
 * and remains unchanged on subsequent calls.
 * 
 * ...
 *
 * @author  Josh Bloch and Doug Lea
 * @since   1.2
 */
public class ThreadLocal&lt;T&gt; {
    //...
}</code></pre>
<blockquote>
<p>大致意思就是，ThreadLocal 提供线程局部的变量，这些变量在每个线程中都有不同的副本，通过get和set方法就可以得到或设置它们。</p>
</blockquote>
<p>类<code>ThreadLocal</code>的结构如下：</p>
<img src="/2019/10/11/210-Java/JavaSE/ThreadLocal%20%E7%90%86%E8%A7%A3/ThreadLocal%E7%90%86%E8%A7%A31.png" class="类&#96;ThreadLocal&#96;的结构">

<p>重要的方法只有两个：<strong>set 和 get</strong></p>
<h3 id="ThreadLocal-set-value"><a href="#ThreadLocal-set-value" class="headerlink" title="ThreadLocal.set(value)"></a>ThreadLocal.set(value)</h3><p><code>ThreadLocal.set(value)</code> 向 <code>Thread</code> 内部的 <code>threadLocals</code> 变量添加值，它的实现如下：</p>
<pre><code class="java">    // line 189
    /**
     * Sets the current thread&#39;s copy of this thread-local variable
     * to the specified value.  Most subclasses will have no need to
     * override this method, relying solely on the {@link #initialValue}
     * method to set the values of thread-locals.
     *
     * @param value the value to be stored in the current thread&#39;s copy of
     *        this thread-local.
     */
    public void set(T value) {
        Thread t = Thread.currentThread();
        // 获取线程内部 ThreadLocalMap 对象
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else// 给线程threadLocals变量new一个ThreadLocalMap对象，并添加第一个键值对
            createMap(t, value);
    }
    ......
    // line 225
    /**
     * Get the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param  t the current thread
     * @return the map
     */
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }

    /**
     * Create the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param t the current thread
     * @param firstValue value for the initial entry of the map
     */
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }</code></pre>
<h3 id="ThreadLocal-get"><a href="#ThreadLocal-get" class="headerlink" title="ThreadLocal.get()"></a>ThreadLocal.get()</h3><pre><code class="java">    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings(&quot;unchecked&quot;)
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p><code>ThreadLocal</code>和<code>Synchronized</code>都是为了解决多线程中相同变量的访问冲突问题，不同的是：</p>
<ul>
<li><code>Synchronized</code> 是通过线程等待，牺牲时间来解决访问冲突</li>
<li><code>ThreadLocal</code> 是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于<code>Synchronized</code>，<code>ThreadLocal</code> 具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</li>
</ul>
</blockquote>
<p>  正因为<code>ThreadLocal</code>的线程隔离特性，使他的应用场景相对来说更为特殊一些。在android中Looper、ActivityThread以及AMS中都用到了ThreadLocal。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。</p>

    </div>
</article>
</main>
</div>
</body>
</html>