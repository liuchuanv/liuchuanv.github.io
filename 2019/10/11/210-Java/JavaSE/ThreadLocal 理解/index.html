<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>静言思之</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/lib/github-markdown-css/github-markdown.css">
</head>
<body>
<div class="container">
<header class="header">
    <div class="blog-title">
        <a href="/" class="logo">静言思之</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">首页</a>
                </li>
            
                <li class="menu-item">
                    <a href="/archives" class="menu-item-link">归档</a>
                </li>
            
                <li class="menu-item">
                    <a href="https://github.com/ahonn" target="_blank" rel="noopener" class="menu-item-link">交友</a>
                </li>
            
        </ul>
    </nav>
</header>
<main class="main">
    <article class="post">
    <div class="post-title">
        <h2 class="title">ThreadLocal 理解</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2019-10-11</span>
    </div>
    <div class="markdown-body">
        <h2 id="线程成员-threadLocals"><a href="#线程成员-threadLocals" class="headerlink" title="线程成员 threadLocals"></a>线程成员 threadLocals</h2><p>线程类Thread内部有一个变量：<code>threadLocals</code></p>
<p>它是 <code>ThreadLocal.ThreadLocalMap</code> 对象</p>
<pre><code class="java">...
public
class Thread implements Runnable {
    ...
    // line 179
    /* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */
    ThreadLocal.ThreadLocalMap threadLocals = null;
    ...
}</code></pre>
<h2 id="类ThreadLocalMap"><a href="#类ThreadLocalMap" class="headerlink" title="类ThreadLocalMap"></a>类ThreadLocalMap</h2><p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的内部类</p>
<pre><code class="java">public class ThreadLocal&lt;T&gt; {
    ...
    // line 287
    /**
     * ThreadLocalMap is a customized hash map suitable only for
     * maintaining thread local values. No operations are exported
     * outside of the ThreadLocal class. The class is package private to
     * allow declaration of fields in class Thread.  To help deal with
     * very large and long-lived usages, the hash table entries use
     * WeakReferences for keys. However, since reference queues are not
     * used, stale entries are guaranteed to be removed only when
     * the table starts running out of space.
     */
    static class ThreadLocalMap {
        // ...
    }
    ...
}    </code></pre>
<blockquote>
<p>ThreadLocalMap is a customized hash map suitable only for maintaining thread local values.</p>
<p>大意：ThreadLocalMap 是一个自定义 HashMap，只适用于线程局部变量。</p>
<p>完全可以把它看做是一个 HashMap。</p>
</blockquote>
<h2 id="类ThreadLocal"><a href="#类ThreadLocal" class="headerlink" title="类ThreadLocal"></a>类ThreadLocal</h2><pre><code class="java">/**
 * This class provides thread-local variables.  These variables differ from
 * their normal counterparts in that each thread that accesses one (via its
 * {@code get} or {@code set} method) has its own, independently initialized
 * copy of the variable.  {@code ThreadLocal} instances are typically private
 * static fields in classes that wish to associate state with a thread (e.g.,
 * a user ID or Transaction ID).
 *
 * &lt;p&gt;For example, the class below generates unique identifiers local to each
 * thread.
 * A thread&#39;s id is assigned the first time it invokes {@code ThreadId.get()}
 * and remains unchanged on subsequent calls.
 * 
 * ...
 *
 * @author  Josh Bloch and Doug Lea
 * @since   1.2
 */
public class ThreadLocal&lt;T&gt; {
    //...
}</code></pre>
<blockquote>
<p>注释大意：ThreadLocal 提供线程局部的变量，这些变量在每个线程中都有不同的副本，通过get和set方法就可以获取和设置它们。</p>
</blockquote>
<p>类<code>ThreadLocal</code>的结构如下：<br><img src="./images/ThreadLocal%E7%90%86%E8%A7%A31.png" alt="类ThreadLocal结构"></p>
<p>重要的方法只有两个：<strong>set 和 get</strong></p>
<h3 id="ThreadLocal-set-value"><a href="#ThreadLocal-set-value" class="headerlink" title="ThreadLocal.set(value)"></a>ThreadLocal.set(value)</h3><p><code>ThreadLocal.set(value)</code> 向 <code>Thread</code> 内部的 <code>threadLocals</code> 变量添加一个元素，它的实现如下：</p>
<pre><code class="java">    // line 189
    /**
     * Sets the current thread&#39;s copy of this thread-local variable
     * to the specified value.  Most subclasses will have no need to
     * override this method, relying solely on the {@link #initialValue}
     * method to set the values of thread-locals.
     *
     * @param value the value to be stored in the current thread&#39;s copy of
     *        this thread-local.
     */
    public void set(T value) {
        Thread t = Thread.currentThread();
        // 获取线程内部 ThreadLocalMap 对象
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else// 给线程threadLocals变量new一个ThreadLocalMap对象，并添加第一个键值对
            createMap(t, value);
    }
    ......
    // line 225
    /**
     * Get the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param  t the current thread
     * @return the map
     */
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }

    /**
     * Create the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param t the current thread
     * @param firstValue value for the initial entry of the map
     */
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }</code></pre>
<h3 id="ThreadLocal-get"><a href="#ThreadLocal-get" class="headerlink" title="ThreadLocal.get()"></a>ThreadLocal.get()</h3><pre><code class="java">    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings(&quot;unchecked&quot;)
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>ThreadLocal 和 Synchronized 都是为了解决多线程中相同变量的访问冲突问题，不同的是：</p>
<ul>
<li>Synchronized 是通过线程等待，牺牲时间来解决访问冲突</li>
<li>ThreadLocal 是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于<code>Synchronized</code>，ThreadLocal 具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</li>
</ul>
</blockquote>
<p>正因为 ThreadLocal 的线程隔离特性，使他的应用场景相对来说更为特殊一些。</p>
<p>当某些数据是 <strong>以线程为作用域并且不同线程具有不同的数据副本</strong> 的时候，就可以考虑采用ThreadLocal。</p>
<p>比如：在多数据源切换时，就使用了 ThreadLocal 来设置当前使用的数据源</p>

    </div>
</article>
</main>
</div>
</body>
</html>