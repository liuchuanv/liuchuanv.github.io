<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>静言思之</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/lib/github-markdown-css/github-markdown.css">
</head>
<body>
<div class="container">
<header class="header">
    <div class="blog-title">
        <a href="/" class="logo">静言思之</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">首页</a>
                </li>
            
                <li class="menu-item">
                    <a href="/archives" class="menu-item-link">归档</a>
                </li>
            
                <li class="menu-item">
                    <a href="https://github.com/ahonn" target="_blank" rel="noopener" class="menu-item-link">交友</a>
                </li>
            
        </ul>
    </nav>
</header>
<main class="main">
    <article class="post">
    <div class="post-title">
        <h2 class="title">Shiro源码解析之SessionManager02-SessionDAO</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2019-10-18</span>
    </div>
    <div class="markdown-body">
        <h2 id="了解-SessionDAO"><a href="#了解-SessionDAO" class="headerlink" title="了解 SessionDAO"></a>了解 SessionDAO</h2><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><p><img src="/blog/images/201910/image-20191028104313016.png" alt="image-20191028104313016"></p>
<h3 id="SessionDAO"><a href="#SessionDAO" class="headerlink" title="SessionDAO"></a>SessionDAO</h3><p><img src="/blog/images/201910/1571367544804.png" alt="1571367544804"></p>
<h3 id="AbstractSessionDAO"><a href="#AbstractSessionDAO" class="headerlink" title="AbstractSessionDAO"></a>AbstractSessionDAO</h3><p><img src="/blog/images/201910/1571367836411.png" alt="1571367836411"><br> <code>SessionIdGenerator sessionIdGenerator</code> 用来生成 sessionId；</p>
<h3 id="CachingSessionDAO"><a href="#CachingSessionDAO" class="headerlink" title="CachingSessionDAO"></a>CachingSessionDAO</h3><p>省略 getter 和 setter<br><img src="/blog/images/201910/1571368167696.png" alt="1571368167696"></p>
<h3 id="EnterpriseCachingSessionDAO"><a href="#EnterpriseCachingSessionDAO" class="headerlink" title="EnterpriseCachingSessionDAO"></a>EnterpriseCachingSessionDAO</h3><p><img src="/blog/images/201910/1571368312829.png" alt="1571368312829"></p>
<h3 id="MemorySessionDAO"><a href="#MemorySessionDAO" class="headerlink" title="MemorySessionDAO"></a>MemorySessionDAO</h3><p><img src="/blog/images/201910/1571369743342.png" alt="1571369743342"></p>
<h2 id="理解-MemorySessionDAO"><a href="#理解-MemorySessionDAO" class="headerlink" title="理解 MemorySessionDAO"></a>理解 MemorySessionDAO</h2><h3 id="create-Session-Serializable"><a href="#create-Session-Serializable" class="headerlink" title="create(Session): Serializable"></a>create(Session): Serializable</h3><h4 id="1-AbstractSessionDAO-create"><a href="#1-AbstractSessionDAO-create" class="headerlink" title="1. AbstractSessionDAO | create()"></a>1. AbstractSessionDAO | <code>create()</code></h4><pre><code class="java">     // line 85
     /**
     * Generates a new ID to be applied to the specified {@code session} instance.  This method is usually called
     * from within a subclass&#39;s {@link #doCreate} implementation where they assign the returned id to the session
     * instance and then create a record with this ID in the EIS data store.
     * &lt;p/&gt;
     * Subclass implementations backed by EIS data stores that auto-generate IDs during record creation, such as
     * relational databases, don&#39;t need to use this method or the {@link #getSessionIdGenerator() sessionIdGenerator}
     * attribute - they can simply return the data store&#39;s generated ID from the {@link #doCreate} implementation
     * if desired.
     * &lt;p/&gt;
     * This implementation uses the {@link #setSessionIdGenerator configured} {@link SessionIdGenerator} to create
     * the ID.
     *
     * @param session the new session instance for which an ID will be generated and then assigned
     * @return the generated ID to assign
     */
    protected Serializable generateSessionId(Session session) {
        if (this.sessionIdGenerator == null) {
            String msg = &quot;sessionIdGenerator attribute has not been configured.&quot;;
            throw new IllegalStateException(msg);
        }
        return this.sessionIdGenerator.generateId(session);
    }

    /**
     * Creates the session by delegating EIS creation to subclasses via the {@link #doCreate} method, and then
     * asserting that the returned sessionId is not null.
     *
     * @param session Session object to create in the EIS and associate with an ID.
     */
    public Serializable create(Session session) {
        // 调用 doCreate()，返回 sessionId
        Serializable sessionId = doCreate(session);
        verifySessionId(sessionId);
        return sessionId;
    }
    /**
     * Ensures the sessionId returned from the subclass implementation of {@link #doCreate} is not null and not
     * already in use.
     *
     * @param sessionId session id returned from the subclass implementation of {@link #doCreate}
     */
    private void verifySessionId(Serializable sessionId) {
        if (sessionId == null) {
            String msg = &quot;sessionId returned from doCreate implementation is null.  Please verify the implementation.&quot;;
            throw new IllegalStateException(msg);
        }
    }
    ......
    // line 156
    /**
     * Subclass hook to actually persist the given &lt;tt&gt;Session&lt;/tt&gt; instance to the underlying EIS.
     *
     * @param session the Session instance to persist to the EIS.
     * @return the id of the session created in the EIS (i.e. this is almost always a primary key and should be the
     *         value returned from {@link org.apache.shiro.session.Session#getId() Session.getId()}.
     */
    protected abstract Serializable doCreate(Session session);

</code></pre>
<h4 id="2-MemorySessionDAO-doCreate"><a href="#2-MemorySessionDAO-doCreate" class="headerlink" title="2. MemorySessionDAO | doCreate()"></a>2. MemorySessionDAO | <code>doCreate()</code></h4><pre><code class="java">    // line 66
    protected Serializable doCreate(Session session) {
        // 生成sessionId 
        Serializable sessionId = generateSessionId(session);
        // 将sessionId填充到 session对象中
        assignSessionId(session, sessionId);
        // 将session存储到ConcurrentHashMap对象中
        storeSession(sessionId, session);
        return sessionId;
    }

    protected Session storeSession(Serializable id, Session session) {
        if (id == null) {
            throw new NullPointerException(&quot;id argument cannot be null.&quot;);
        }
        return sessions.putIfAbsent(id, session);
    }</code></pre>
<blockquote>
<p>ConcurrentHashMap 是线程安全的 HashMap</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>生成 sessionId （MemorySessionDAO）</li>
<li>将 sessionId 填充到 session中（MemorySessionDAO）</li>
<li>将 session 存储到 ConcurrentHashMap 对象sessions中，sessionId 作为key（MemorySessionDAO）</li>
<li>验证 sessionId 是否为空</li>
<li>返回 sessionId</li>
</ol>
<h3 id="readSession-Serializable-Session"><a href="#readSession-Serializable-Session" class="headerlink" title="readSession(Serializable): Session"></a>readSession(Serializable): Session</h3><h4 id="1-AbstractSessionDAO-readSession"><a href="#1-AbstractSessionDAO-readSession" class="headerlink" title="1. AbstractSessionDAO | readSession()"></a>1. AbstractSessionDAO | <code>readSession()</code></h4><pre><code class="java">    // line 158
    /**
     * Retrieves the Session object from the underlying EIS identified by &lt;tt&gt;sessionId&lt;/tt&gt; by delegating to
     * the {@link #doReadSession(java.io.Serializable)} method.  If {@code null} is returned from that method, an
     * {@link UnknownSessionException} will be thrown.
     *
     * @param sessionId the id of the session to retrieve from the EIS.
     * @return the session identified by &lt;tt&gt;sessionId&lt;/tt&gt; in the EIS.
     * @throws UnknownSessionException if the id specified does not correspond to any session in the EIS.
     */
    public Session readSession(Serializable sessionId) throws UnknownSessionException {
        Session s = doReadSession(sessionId);
        if (s == null) {
            throw new UnknownSessionException(&quot;There is no session with id [&quot; + sessionId + &quot;]&quot;);
        }
        return s;
    }

    /**
     * Subclass implementation hook that retrieves the Session object from the underlying EIS or {@code null} if a
     * session with that ID could not be found.
     *
     * @param sessionId the id of the &lt;tt&gt;Session&lt;/tt&gt; to retrieve.
     * @return the Session in the EIS identified by &lt;tt&gt;sessionId&lt;/tt&gt; or {@code null} if a
     *         session with that ID could not be found.
     */
    protected abstract Session doReadSession(Serializable sessionId);</code></pre>
<h4 id="2-MemorySessionDAO-doReadSession"><a href="#2-MemorySessionDAO-doReadSession" class="headerlink" title="2. MemorySessionDAO | doReadSession()"></a>2. MemorySessionDAO | <code>doReadSession()</code></h4><pre><code class="java">    // line 80
    protected Session doReadSession(Serializable sessionId) {
        return sessions.get(sessionId);
    }</code></pre>
<h3 id="update-Session-void"><a href="#update-Session-void" class="headerlink" title="update(Session): void"></a>update(Session): void</h3><h4 id="MemorySessionDAO-update"><a href="#MemorySessionDAO-update" class="headerlink" title="MemorySessionDAO | update()"></a>MemorySessionDAO | <code>update()</code></h4><pre><code class="java">    // line 72
    protected Session storeSession(Serializable id, Session session) {
        if (id == null) {
            throw new NullPointerException(&quot;id argument cannot be null.&quot;);
        }
        return sessions.putIfAbsent(id, session);
    }    
    // line 84
    public void update(Session session) throws UnknownSessionException {
        storeSession(session.getId(), session);
    }</code></pre>
<h3 id="delete-Session-void"><a href="#delete-Session-void" class="headerlink" title="delete(Session): void"></a>delete(Session): void</h3><h4 id="MemorySessionDAO-delete"><a href="#MemorySessionDAO-delete" class="headerlink" title="MemorySessionDAO | delete()"></a>MemorySessionDAO | <code>delete()</code></h4><pre><code class="java">    // line 88
    public void delete(Session session) {
        if (session == null) {
            throw new NullPointerException(&quot;session argument cannot be null.&quot;);
        }
        Serializable id = session.getId();
        if (id != null) {
            sessions.remove(id);
        }
    }</code></pre>
<h2 id="理解-EnterpiseCachingSessionDAO"><a href="#理解-EnterpiseCachingSessionDAO" class="headerlink" title="理解 EnterpiseCachingSessionDAO"></a>理解 EnterpiseCachingSessionDAO</h2><h3 id="create-Session-Serializable-1"><a href="#create-Session-Serializable-1" class="headerlink" title="create(Session): Serializable"></a>create(Session): Serializable</h3><h4 id="1-CachingSessionDAO-中重写了-readSession"><a href="#1-CachingSessionDAO-中重写了-readSession" class="headerlink" title="1. CachingSessionDAO 中重写了 readSession()"></a>1. CachingSessionDAO 中重写了 <code>readSession()</code></h4><pre><code class="java">    // line 177
    /**
     * Calls {@code super.create(session)}, then caches the session keyed by the returned {@code sessionId}, and then
     * returns this {@code sessionId}.
     *
     * @param session Session object to create in the EIS and then cache.
     */
    public Serializable create(Session session) {
        // 调用父类的create()方法，参考 MemorySessionDAO 中 AbstractSessionDAO 的 create() 方法
        // 内部调用 doCreate() ，然后验证 sessionId
        Serializable sessionId = super.create(session);
        // 缓存session
        cache(session, sessionId);
        return sessionId;
    }</code></pre>
<h4 id="2-EnterpriseCachingSessioDAO-doCreate"><a href="#2-EnterpriseCachingSessioDAO-doCreate" class="headerlink" title="2. EnterpriseCachingSessioDAO | doCreate()"></a>2. EnterpriseCachingSessioDAO | <code>doCreate()</code></h4><pre><code class="java">    // line 63
    protected Serializable doCreate(Session session) {
        Serializable sessionId = generateSessionId(session);
        assignSessionId(session, sessionId);
        return sessionId;
    }</code></pre>
<h4 id="3-CachingSessionDAO-cache-session-sessionId"><a href="#3-CachingSessionDAO-cache-session-sessionId" class="headerlink" title="3. CachingSessionDAO | cache(session, sessionId)"></a>3. CachingSessionDAO | <code>cache(session, sessionId)</code></h4><pre><code class="java">    ......
    // line 141
    /**
     * Returns the active sessions cache, but if that cache instance is null, first lazily creates the cache instance
     * via the {@link #createActiveSessionsCache()} method and then returns the instance.
     * &lt;p/&gt;
     * Note that this method will only return a non-null value code if the {@code CacheManager} has been set.  If
     * not set, there will be no cache.
     *
     * @return the active sessions cache instance.
     */
    private Cache&lt;Serializable, Session&gt; getActiveSessionsCacheLazy() {
        if (this.activeSessions == null) {
            this.activeSessions = createActiveSessionsCache();
        }
        return activeSessions;
    }


    // line 157
    /**
     * Creates a cache instance used to store active sessions.  Creation is done by first
     * {@link #getCacheManager() acquiring} the {@code CacheManager}.  If the cache manager is not null, the
     * cache returned is that resulting from the following call:
     * &lt;pre&gt;       String name = {@link #getActiveSessionsCacheName() getActiveSessionsCacheName()};
     * cacheManager.getCache(name);&lt;/pre&gt;
     *
     * @return a cache instance used to store active sessions, or {@code null} if the {@code CacheManager} has
     *         not been set.
     */
    protected Cache&lt;Serializable, Session&gt; createActiveSessionsCache() {
        Cache&lt;Serializable, Session&gt; cache = null;
        CacheManager mgr = getCacheManager();
        if (mgr != null) {
            String name = getActiveSessionsCacheName();
            cache = mgr.getCache(name);
        }
        return cache;
    }

    ......

    // line 220
    /**
     * Caches the specified session under the cache entry key of {@code sessionId}.
     *
     * @param session   the session to cache
     * @param sessionId the session id, to be used as the cache entry key.
     * @since 1.0
     */
    protected void cache(Session session, Serializable sessionId) {
        if (session == null || sessionId == null) {
            return;
        }
        // 获取 cache 
        Cache&lt;Serializable, Session&gt; cache = getActiveSessionsCacheLazy();
        if (cache == null) {
            return;
        }
        // 将 session 存储到 cache 中，sessionId 作为 key
        cache(session, sessionId, cache);
    }

    /**
     * Caches the specified session in the given cache under the key of {@code sessionId}.  This implementation
     * simply calls {@code cache.put(sessionId,session)} and can be overridden for custom behavior.
     *
     * @param session   the session to cache
     * @param sessionId the id of the session, expected to be the cache key.
     * @param cache     the cache to store the session
     */
    protected void cache(Session session, Serializable sessionId, Cache&lt;Serializable, Session&gt; cache) {
        cache.put(sessionId, session);
    }
</code></pre>
<p><code>EnterpriseCachingSessionDAO</code> 构造函数中设置了默认的 <code>CacheManager</code></p>
<pre><code class="java">    public EnterpriseCacheSessionDAO() {
        setCacheManager(new AbstractCacheManager() {
            @Override
            protected Cache&lt;Serializable, Session&gt; createCache(String name) throws CacheException {
                return new MapCache&lt;Serializable, Session&gt;(name, new ConcurrentHashMap&lt;Serializable, Session&gt;());
            }
        });
    }</code></pre>
<p>从中可以看出，实际中 <code>MapCache</code> 内部也是使用 <code>ConcurrentHashMap</code>对象来存储session的。</p>
<h3 id="readSession-Serializable-Session-1"><a href="#readSession-Serializable-Session-1" class="headerlink" title="readSession(Serializable): Session"></a>readSession(Serializable): Session</h3><h4 id="1-CachingSessionDAO-readSession"><a href="#1-CachingSessionDAO-readSession" class="headerlink" title="1. CachingSessionDAO | readSession()"></a>1. CachingSessionDAO | <code>readSession()</code></h4><pre><code class="java">    // line 250
    /**
     * Attempts to acquire the Session from the cache first using the session ID as the cache key.  If no session
     * is found, {@code super.readSession(sessionId)} is called to perform the actual retrieval.
     *
     * @param sessionId the id of the session to retrieve from the EIS.
     * @return the session identified by {@code sessionId} in the EIS.
     * @throws UnknownSessionException if the id specified does not correspond to any session in the cache or EIS.
     */
    public Session readSession(Serializable sessionId) throws UnknownSessionException {
        // 根据 sessionId 获取缓存的 session
        Session s = getCachedSession(sessionId);
        if (s == null) {
            // 调用父类方法 readSession 获取 session
            // 其内部调用 doReadSession() 获取session
            s = super.readSession(sessionId);
        }
        return s;
    }
    ......

    // line 189
    /**
     * Returns the cached session with the corresponding {@code sessionId} or {@code null} if there is
     * no session cached under that id (or if there is no Cache).
     *
     * @param sessionId the id of the cached session to acquire.
     * @return the cached session with the corresponding {@code sessionId}, or {@code null} if the session
     *         does not exist or is not cached.
     */
    protected Session getCachedSession(Serializable sessionId) {
        Session cached = null;
        if (sessionId != null) {
            Cache&lt;Serializable, Session&gt; cache = getActiveSessionsCacheLazy();
            if (cache != null) {
                cached = getCachedSession(sessionId, cache);
            }
        }
        return cached;
    }

    /**
     * Returns the Session with the specified id from the specified cache.  This method simply calls
     * {@code cache.get(sessionId)} and can be overridden by subclasses for custom acquisition behavior.
     *
     * @param sessionId the id of the session to acquire.
     * @param cache     the cache to acquire the session from
     * @return the cached session, or {@code null} if the session wasn&#39;t in the cache.
     */
    protected Session getCachedSession(Serializable sessionId, Cache&lt;Serializable, Session&gt; cache) {
        return cache.get(sessionId);
    }</code></pre>
<p><code>EnterpriseCachingSessionDAO</code> 中实现了 <code>doReadSession()</code></p>
<pre><code class="java">    protected Session doReadSession(Serializable sessionId) {
        return null; //should never execute because this implementation relies on parent class to access cache, which
        //is where all sessions reside - it is the cache implementation that determines if the
        //cache is memory only or disk-persistent, etc.
    }</code></pre>
<h3 id="update-Session-void-1"><a href="#update-Session-void-1" class="headerlink" title="update(Session): void"></a>update(Session): void</h3><h4 id="1-CachingSessionDAO-中实现了-update"><a href="#1-CachingSessionDAO-中实现了-update" class="headerlink" title="1. CachingSessionDAO 中实现了 update()"></a>1. CachingSessionDAO 中实现了 <code>update()</code></h4><pre><code class="java">    // line 266
    /**
     * Updates the state of the given session to the EIS by first delegating to
     * {@link #doUpdate(org.apache.shiro.session.Session)}.  If the session is a {@link ValidatingSession}, it will
     * be added to the cache only if it is {@link ValidatingSession#isValid()} and if invalid, will be removed from the
     * cache.  If it is not a {@code ValidatingSession} instance, it will be added to the cache in any event.
     *
     * @param session the session object to update in the EIS.
     * @throws UnknownSessionException if no existing EIS session record exists with the
     *                                 identifier of {@link Session#getId() session.getId()}
     */
    public void update(Session session) throws UnknownSessionException {
        doUpdate(session);
        // 判断session是否是 ValidatingSession 实例
        if (session instanceof ValidatingSession) {
            // 判断 session 是否有效
            if (((ValidatingSession) session).isValid()) {
                cache(session, session.getId());
            } else {
                uncache(session);
            }
        } else {
            cache(session, session.getId());
        }
    }
</code></pre>
<h4 id="2-EnterpriseCachingSessionDAO-doUpdate"><a href="#2-EnterpriseCachingSessionDAO-doUpdate" class="headerlink" title="2. EnterpriseCachingSessionDAO | doUpdate()"></a>2. EnterpriseCachingSessionDAO | <code>doUpdate()</code></h4><pre><code class="java">    protected void doUpdate(Session session) {
        //does nothing - parent class persists to cache.
    }</code></pre>
<h3 id="delete-Session-void-1"><a href="#delete-Session-void-1" class="headerlink" title="delete(Session): void"></a>delete(Session): void</h3><h4 id="1-CachingSessionDAO-delete"><a href="#1-CachingSessionDAO-delete" class="headerlink" title="1. CachingSessionDAO | delete()"></a>1. CachingSessionDAO | <code>delete()</code></h4><pre><code class="java">    /**
     * Removes the specified session from any cache and then permanently deletes the session from the EIS by
     * delegating to {@link #doDelete}.
     *
     * @param session the session to remove from caches and permanently delete from the EIS.
     */
    public void delete(Session session) {
        // 删除缓存中的session
        uncache(session);
        // 调用 doDelete()
        doDelete(session);
    }</code></pre>
<h4 id="2-EnterpriseCachingSessionDAO-doDelete"><a href="#2-EnterpriseCachingSessionDAO-doDelete" class="headerlink" title="2. EnterpriseCachingSessionDAO | doDelete()"></a>2. EnterpriseCachingSessionDAO | <code>doDelete()</code></h4><pre><code class="java">    protected void doDelete(Session session) {
        //does nothing - parent class removes from cache.
    }</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>SessionDAO</code>用于 session 存储，它有两个实现：</p>
<ul>
<li><code>MemorySessionDAO</code> 使用 <code>ConcurrentHashMap</code> 对象将 session 保存到内存中</li>
<li><code>EnterpriseCachingSessionDAO</code> 将session保存到缓存中（该缓存默认使用 <code>ConcurrentHashMap</code> 保存到内存中）。其实 <code>EnterpriseCachingSessionDAO</code> 就是一个对外的接口，用户自定义SessionDAO时，只需继承他。</li>
</ul>

    </div>
</article>
</main>
</div>
</body>
</html>