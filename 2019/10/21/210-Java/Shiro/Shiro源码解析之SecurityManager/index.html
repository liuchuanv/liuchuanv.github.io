<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>静言思之</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/lib/github-markdown-css/github-markdown.css">
</head>
<body>
<div class="container">
<header class="header">
    <div class="blog-title">
        <a href="/" class="logo">静言思之</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">首页</a>
                </li>
            
                <li class="menu-item">
                    <a href="/archives" class="menu-item-link">归档</a>
                </li>
            
                <li class="menu-item">
                    <a href="https://github.com/ahonn" target="_blank" rel="noopener" class="menu-item-link">交友</a>
                </li>
            
        </ul>
    </nav>
</header>
<main class="main">
    <article class="post">
    <div class="post-title">
        <h2 class="title">Shiro源码解析之SecurityManager</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2019-10-21</span>
    </div>
    <div class="markdown-body">
        <h2 id="了解-SecurityManger"><a href="#了解-SecurityManger" class="headerlink" title="了解 SecurityManger"></a>了解 SecurityManger</h2><h3 id="继承图"><a href="#继承图" class="headerlink" title="继承图"></a>继承图</h3><p>在<code>SecurityManager</code>接口名称上按 <kbd>Ctrl</kbd>+<kbd>H</kbd>，显示它的继承层次<br><img src="/blog/images/201910/1571642320953.png" alt="1571642320953"></p>
<p>在<code>DefaultWebSecurityManager</code>类名称上按 <kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>U</kbd>，显示它的继承图<br><img src="/blog/images/201910/1571642933389.png" alt="1571642933389"></p>
<h3 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h3><p><img src="/blog/images/201910/1571642162627.png" alt="SecurityManger结构"></p>
<h3 id="CachingSecurityManager"><a href="#CachingSecurityManager" class="headerlink" title="CachingSecurityManager"></a>CachingSecurityManager</h3><p><img src="/blog/images/201910/1571707959571.png" alt="1571707959571"></p>
<h3 id="RealmSecurityManager"><a href="#RealmSecurityManager" class="headerlink" title="RealmSecurityManager"></a>RealmSecurityManager</h3><p><img src="/blog/images/201910/1571708033085.png" alt="1571708033085"></p>
<h3 id="AuthenticatingSecurityManager"><a href="#AuthenticatingSecurityManager" class="headerlink" title="AuthenticatingSecurityManager"></a>AuthenticatingSecurityManager</h3><p><img src="/blog/images/201910/1571708079963.png" alt="1571708079963"></p>
<h3 id="AuthorizingSecurityManager"><a href="#AuthorizingSecurityManager" class="headerlink" title="AuthorizingSecurityManager"></a>AuthorizingSecurityManager</h3><p><img src="/blog/images/201910/1571708160461.png" alt="1571708160461"></p>
<h3 id="SessionSecurityManager"><a href="#SessionSecurityManager" class="headerlink" title="SessionSecurityManager"></a>SessionSecurityManager</h3><p><img src="/blog/images/201910/1571708232562.png" alt="1571708232562"></p>
<h3 id="DefaultSecurityManager"><a href="#DefaultSecurityManager" class="headerlink" title="DefaultSecurityManager"></a>DefaultSecurityManager</h3><p><img src="/blog/images/201910/1571708376374.png" alt="1571708376374"></p>
<p>方法看上去很多，但我们只需关注其对顶层接口 <code>SecurityManager</code> 方法的实现</p>
<h3 id="DefaultSecurityManager-1"><a href="#DefaultSecurityManager-1" class="headerlink" title="DefaultSecurityManager"></a>DefaultSecurityManager</h3><p><img src="/blog/images/201910/1571708790577.png" alt="1571708790577"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SecurityManager的继承结构大量使用了 <strong>装饰模式</strong></p>
<h2 id="理解-SecurityManager"><a href="#理解-SecurityManager" class="headerlink" title="理解 SecurityManager"></a>理解 SecurityManager</h2><p>从顶层接口 SecurityManger 暴露出的三个方法来入手，分别解析它们的逻辑流程</p>
<p><img src="/blog/images/201910/1571642162627.png" alt="SecurityManger结构"></p>
<h3 id="login-Subject-AuthenticationToken-Subject"><a href="#login-Subject-AuthenticationToken-Subject" class="headerlink" title="login(Subject, AuthenticationToken): Subject"></a>login(Subject, AuthenticationToken): Subject</h3><h4 id="1-login-subject-token-DefaultSecurityManager"><a href="#1-login-subject-token-DefaultSecurityManager" class="headerlink" title="1. login(subject, token) | DefaultSecurityManager"></a>1. <code>login(subject, token)</code> | DefaultSecurityManager</h4><pre><code class="java">    // line 259
    /**
     * First authenticates the {@code AuthenticationToken} argument, and if successful, constructs a
     * {@code Subject} instance representing the authenticated account&#39;s identity.
     * &lt;p/&gt;
     * Once constructed, the {@code Subject} instance is then {@link #bind bound} to the application for
     * subsequent access before being returned to the caller.
     *
     * @param token the authenticationToken to process for the login attempt.
     * @return a Subject representing the authenticated user.
     * @throws AuthenticationException if there is a problem authenticating the specified {@code token}.
     */
    public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException {
        AuthenticationInfo info;
        try {
            info = authenticate(token);
        } catch (AuthenticationException ae) {
            try {
                onFailedLogin(token, ae, subject);
            } catch (Exception e) {
                if (log.isInfoEnabled()) {
                    log.info(&quot;onFailedLogin method threw an &quot; +
                            &quot;exception.  Logging and propagating original AuthenticationException.&quot;, e);
                }
            }
            throw ae; //propagate
        }

        Subject loggedIn = createSubject(token, info, subject);

        onSuccessfulLogin(token, info, loggedIn);

        return loggedIn;
    }
</code></pre>
<h4 id="2-authencate-token-AuthenticatingSecurityManager"><a href="#2-authencate-token-AuthenticatingSecurityManager" class="headerlink" title="2. authencate(token) | AuthenticatingSecurityManager"></a>2. <code>authencate(token)</code> | AuthenticatingSecurityManager</h4><pre><code class="java">    // line 50
    /**
     * Default no-arg constructor that initializes its internal
     * &lt;code&gt;authenticator&lt;/code&gt; instance to a
     * {@link org.apache.shiro.authc.pam.ModularRealmAuthenticator ModularRealmAuthenticator}.
     */
    public AuthenticatingSecurityManager() {
        super();
        // 默认 Authenticator
        this.authenticator = new ModularRealmAuthenticator();
    }
    ...... 
    // line 101
    /**
     * Delegates to the wrapped {@link org.apache.shiro.authc.Authenticator Authenticator} for authentication.
     */
    public AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException {
        return this.authenticator.authenticate(token);
    }</code></pre>
<p><code>authenticator.authenticate(token)</code> 的解析请参考 <a href="Shiro源码解析之Authenticator">Shiro源码解析之Authenticator</a></p>
<h4 id="3-createSubject-token-info-subject-DefaultSecurityManager"><a href="#3-createSubject-token-info-subject-DefaultSecurityManager" class="headerlink" title="3. createSubject(token, info, subject) | DefaultSecurityManager"></a>3. <code>createSubject(token, info, subject)</code> | DefaultSecurityManager</h4><pre><code class="java">    // line 166
    protected SubjectContext createSubjectContext() {
        return new DefaultSubjectContext();
    }
    /**
     * Creates a {@code Subject} instance for the user represented by the given method arguments.
     *
     * @param token    the {@code AuthenticationToken} submitted for the successful authentication.
     * @param info     the {@code AuthenticationInfo} of a newly authenticated user.
     * @param existing the existing {@code Subject} instance that initiated the authentication attempt
     * @return the {@code Subject} instance that represents the context and session data for the newly
     *         authenticated subject.
     */
    protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info, Subject existing) {
        SubjectContext context = createSubjectContext();
        context.setAuthenticated(true);
        // 将 token、authenticationInfo、subject 存入 subjectContext 的 backingMap 中
        context.setAuthenticationToken(token);
        context.setAuthenticationInfo(info);
        if (existing != null) {
            context.setSubject(existing);
        }
        return createSubject(context);
    }</code></pre>
<p>关于<code>createSubject(context)</code> 解析参考 <a href="createSubject(subjectContext">createSubject(subjectContext): Subject</a>: Subject)</p>
<h3 id="createSubject-subjectContext-Subject"><a href="#createSubject-subjectContext-Subject" class="headerlink" title="createSubject(subjectContext): Subject"></a>createSubject(subjectContext): Subject</h3><h4 id="1-createSubject-subjectContext-DefaultSecurityManager"><a href="#1-createSubject-subjectContext-DefaultSecurityManager" class="headerlink" title="1. createSubject(subjectContext) | DefaultSecurityManager"></a>1. <code>createSubject(subjectContext)</code> | DefaultSecurityManager</h4><pre><code class="java">    /**
     * This implementation functions as follows:
     * &lt;p/&gt;
     * &lt;ol&gt;
     * &lt;li&gt;Ensures the {@code SubjectContext} is as populated as it can be, using heuristics to acquire
     * data that may not have already been available to it (such as a referenced session or remembered principals).&lt;/li&gt;
     * &lt;li&gt;Calls {@link #doCreateSubject(org.apache.shiro.subject.SubjectContext)} to actually perform the
     * {@code Subject} instance creation.&lt;/li&gt;
     * &lt;li&gt;calls {@link #save(org.apache.shiro.subject.Subject) save(subject)} to ensure the constructed
     * {@code Subject}&#39;s state is accessible for future requests/invocations if necessary.&lt;/li&gt;
     * &lt;li&gt;returns the constructed {@code Subject} instance.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param subjectContext any data needed to direct how the Subject should be constructed.
     * @return the {@code Subject} instance reflecting the specified contextual data.
     * @see #ensureSecurityManager(org.apache.shiro.subject.SubjectContext)
     * @see #resolveSession(org.apache.shiro.subject.SubjectContext)
     * @see #resolvePrincipals(org.apache.shiro.subject.SubjectContext)
     * @see #doCreateSubject(org.apache.shiro.subject.SubjectContext)
     * @see #save(org.apache.shiro.subject.Subject)
     * @since 1.0
     */
    public Subject createSubject(SubjectContext subjectContext) {
        //create a copy so we don&#39;t modify the argument&#39;s backing map:
        SubjectContext context = copy(subjectContext);

        //ensure that the context has a SecurityManager instance, and if not, add one:
        context = ensureSecurityManager(context);

        //Resolve an associated Session (usually based on a referenced session ID), and place it in the context before
        //sending to the SubjectFactory.  The SubjectFactory should not need to know how to acquire sessions as the
        //process is often environment specific - better to shield the SF from these details:
        context = resolveSession(context);

        //Similarly, the SubjectFactory should not require any concept of RememberMe - translate that here first
        //if possible before handing off to the SubjectFactory:
        context = resolvePrincipals(context);

        Subject subject = doCreateSubject(context);

        //save this subject for future reference if necessary:
        //(this is needed here in case rememberMe principals were resolved and they need to be stored in the
        //session, so we don&#39;t constantly rehydrate the rememberMe PrincipalCollection on every operation).
        //Added in 1.2:
        save(subject);

        return subject;
    }

    /**
     * Actually creates a {@code Subject} instance by delegating to the internal
     * {@link #getSubjectFactory() subjectFactory}.  By the time this method is invoked, all possible
     * {@code SubjectContext} data (session, principals, et. al.) has been made accessible using all known heuristics
     * and will be accessible to the {@code subjectFactory} via the {@code subjectContext.resolve*} methods.
     *
     * @param context the populated context (data map) to be used by the {@code SubjectFactory} when creating a
     *                {@code Subject} instance.
     * @return a {@code Subject} instance reflecting the data in the specified {@code SubjectContext} data map.
     * @see #getSubjectFactory()
     * @see SubjectFactory#createSubject(org.apache.shiro.subject.SubjectContext)
     * @since 1.2
     */
    protected Subject doCreateSubject(SubjectContext context) {
        return getSubjectFactory().createSubject(context);
    }

    /**
     * Saves the subject&#39;s state to a persistent location for future reference if necessary.
     * &lt;p/&gt;
     * This implementation merely delegates to the internal {@link #setSubjectDAO(SubjectDAO) subjectDAO} and calls
     * {@link SubjectDAO#save(org.apache.shiro.subject.Subject) subjectDAO.save(subject)}.
     *
     * @param subject the subject for which state will potentially be persisted
     * @see SubjectDAO#save(org.apache.shiro.subject.Subject)
     * @since 1.2
     */
    protected void save(Subject subject) {
        this.subjectDAO.save(subject);
    }
</code></pre>
<p>createSubject(subjectContext) 中那几个 resolveXxx 方法的解析，请看 <a href="">Shiro源码解析之Subject和SubjectContext</a></p>
<h4 id="2-getSubjectFacotry-createSubject"><a href="#2-getSubjectFacotry-createSubject" class="headerlink" title="2. getSubjectFacotry().createSubject()"></a>2. <code>getSubjectFacotry().createSubject()</code></h4><p>这个方法在 <code>DefaultSubjectFactory</code>、<code>DefaultWebSubjectFactory</code> 分别有一个实现，如下：</p>
<pre><code class="java">    public Subject createSubject(SubjectContext context) {
        SecurityManager securityManager = context.resolveSecurityManager();
        Session session = context.resolveSession();
        boolean sessionCreationEnabled = context.isSessionCreationEnabled();
        PrincipalCollection principals = context.resolvePrincipals();
        boolean authenticated = context.resolveAuthenticated();
        String host = context.resolveHost();

        return new DelegatingSubject(principals, authenticated, host, session, sessionCreationEnabled, securityManager);
    }</code></pre>
<pre><code class="java">    public Subject createSubject(SubjectContext context) {
        if (!(context instanceof WebSubjectContext)) {
            return super.createSubject(context);
        }
        WebSubjectContext wsc = (WebSubjectContext) context;
        SecurityManager securityManager = wsc.resolveSecurityManager();
        Session session = wsc.resolveSession();
        boolean sessionEnabled = wsc.isSessionCreationEnabled();
        PrincipalCollection principals = wsc.resolvePrincipals();
        boolean authenticated = wsc.resolveAuthenticated();
        String host = wsc.resolveHost();
        // web 应用特有的
        ServletRequest request = wsc.resolveServletRequest();
        ServletResponse response = wsc.resolveServletResponse();

        return new WebDelegatingSubject(principals, authenticated, host, session, sessionEnabled,
                request, response, securityManager);
    }</code></pre>
<p>通过 debug 我们来看一下，第一次 getSubject() 得到的 subject 对象里包含哪些属性</p>
<p><img src="/blog/images/201910/image-20191025104928852.png" alt="image-20191025104928852"></p>
<p>顺便看一下 SecurityManager 中的属性方法</p>
<p><img src="/blog/images/201910/image-20191025110723800.png" alt="image-20191025110723800"></p>
<h4 id="3-save-subject-void-DefaultSecurityManager"><a href="#3-save-subject-void-DefaultSecurityManager" class="headerlink" title="3. save(subject): void | DefaultSecurityManager"></a>3. <code>save(subject): void</code> | DefaultSecurityManager</h4><p>这个方法调用了 <code>this.subjectDAO.save(subject)</code></p>
<pre><code class="java">    // line 133
    /**
     * Saves the subject&#39;s state to the subject&#39;s {@link org.apache.shiro.subject.Subject#getSession() session} only
     * if {@link #isSessionStorageEnabled(Subject) sessionStorageEnabled(subject)}.  If session storage is not enabled
     * for the specific {@code Subject}, this method does nothing.
     * &lt;p/&gt;
     * In either case, the argument {@code Subject} is returned directly (a new Subject instance is not created).
     *
     * @param subject the Subject instance for which its state will be created or updated.
     * @return the same {@code Subject} passed in (a new Subject instance is not created).
     */
    public Subject save(Subject subject) {
        if (isSessionStorageEnabled(subject)) {
            saveToSession(subject);
        } else {
            log.trace(&quot;Session storage of subject state for Subject [{}] has been disabled: identity and &quot; +
                    &quot;authentication state are expected to be initialized on every request or invocation.&quot;, subject);
        }

        return subject;
    }

    /**
     * Saves the subject&#39;s state (it&#39;s principals and authentication state) to its
     * {@link org.apache.shiro.subject.Subject#getSession() session}.  The session can be retrieved at a later time
     * (typically from a {@link org.apache.shiro.session.mgt.SessionManager SessionManager} to be used to recreate
     * the {@code Subject} instance.
     *
     * @param subject the subject for which state will be persisted to its session.
     */
    protected void saveToSession(Subject subject) {
        //performs merge logic, only updating the Subject&#39;s session if it does not match the current state:
        mergePrincipals(subject);
        mergeAuthenticationState(subject);
    }

    // line 172
    /**
     * Merges the Subject&#39;s current {@link org.apache.shiro.subject.Subject#getPrincipals()} with whatever may be in
     * any available session.  Only updates the Subject&#39;s session if the session does not match the current principals
     * state.
     *
     * @param subject the Subject for which principals will potentially be merged into the Subject&#39;s session.
     */
    protected void mergePrincipals(Subject subject) {
        //merge PrincipalCollection state:

        PrincipalCollection currentPrincipals = null;

        //SHIRO-380: added if/else block - need to retain original (source) principals
        //This technique (reflection) is only temporary - a proper long term solution needs to be found,
        //but this technique allowed an immediate fix that is API point-version forwards and backwards compatible
        //
        //A more comprehensive review / cleaning of runAs should be performed for Shiro 1.3 / 2.0 +
        if (subject.isRunAs() &amp;&amp; subject instanceof DelegatingSubject) {
            try {
                Field field = DelegatingSubject.class.getDeclaredField(&quot;principals&quot;);
                field.setAccessible(true);
                currentPrincipals = (PrincipalCollection)field.get(subject);
            } catch (Exception e) {
                throw new IllegalStateException(&quot;Unable to access DelegatingSubject principals property.&quot;, e);
            }
        }
        if (currentPrincipals == null || currentPrincipals.isEmpty()) {
            currentPrincipals = subject.getPrincipals();
        }

        Session session = subject.getSession(false);

        if (session == null) {
            if (!isEmpty(currentPrincipals)) {
                session = subject.getSession();
                session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals);
            }
            // otherwise no session and no principals - nothing to save
        } else {
            PrincipalCollection existingPrincipals =
                    (PrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);

            if (isEmpty(currentPrincipals)) {
                if (!isEmpty(existingPrincipals)) {
                    session.removeAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);
                }
                // otherwise both are null or empty - no need to update the session
            } else {
                if (!currentPrincipals.equals(existingPrincipals)) {
                    session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals);
                }
                // otherwise they&#39;re the same - no need to update the session
            }
        }
    }

    /**
     * Merges the Subject&#39;s current authentication state with whatever may be in
     * any available session.  Only updates the Subject&#39;s session if the session does not match the current
     * authentication state.
     *
     * @param subject the Subject for which principals will potentially be merged into the Subject&#39;s session.
     */
    protected void mergeAuthenticationState(Subject subject) {

        Session session = subject.getSession(false);

        if (session == null) {
            if (subject.isAuthenticated()) {
                session = subject.getSession();
                session.setAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY, Boolean.TRUE);
            }
            //otherwise no session and not authenticated - nothing to save
        } else {
            Boolean existingAuthc = (Boolean) session.getAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY);

            if (subject.isAuthenticated()) {
                if (existingAuthc == null || !existingAuthc) {
                    session.setAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY, Boolean.TRUE);
                }
                //otherwise authc state matches - no need to update the session
            } else {
                if (existingAuthc != null) {
                    //existing doesn&#39;t match the current state - remove it:
                    session.removeAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY);
                }
                //otherwise not in the session and not authenticated - no need to update the session
            }
        }
    }
</code></pre>
<h2 id="理解-subject-login"><a href="#理解-subject-login" class="headerlink" title="理解 subject.login()"></a>理解 subject.login()</h2><p>从众多 SecurityManager 的方法图中可知，只有 <code>DefaultSecurityManager</code> 实现了 <code>login()</code> 方法，所以从它的源码开始解析。</p>
<p>*<em>1. DefaultSecurityManager | <code>login(token)</code> *</em></p>
<pre><code class="java">    // line 259
    /**
     * First authenticates the {@code AuthenticationToken} argument, and if successful, constructs a
     * {@code Subject} instance representing the authenticated account&#39;s identity.
     * &lt;p/&gt;
     * Once constructed, the {@code Subject} instance is then {@link #bind bound} to the application for
     * subsequent access before being returned to the caller.
     *
     * @param token the authenticationToken to process for the login attempt.
     * @return a Subject representing the authenticated user.
     * @throws AuthenticationException if there is a problem authenticating the specified {@code token}.
     */
    public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException {
        AuthenticationInfo info;
        try {
            info = authenticate(token);
        } catch (AuthenticationException ae) {
            try {
                onFailedLogin(token, ae, subject);
            } catch (Exception e) {
                if (log.isInfoEnabled()) {
                    log.info(&quot;onFailedLogin method threw an &quot; +
                            &quot;exception.  Logging and propagating original AuthenticationException.&quot;, e);
                }
            }
            throw ae; //propagate
        }

        Subject loggedIn = createSubject(token, info, subject);

        onSuccessfulLogin(token, info, loggedIn);

        return loggedIn;
    }</code></pre>
<p>** 2. AuthenticatingSecurityManager | <code>authenticate(token)</code> **</p>
<p>** 3. ModularRealmAuthenticator | <code>authenticate(token)</code><br>查看源码的时候，一直弄不懂 ModularRealmAuthenticator 对象中的 <code>Collection&lt;Realm&gt; realms</code> 是什么时候赋值的。<br>因为我们只是 <code>securityManager.setRealm(userRealm)</code> 这样的方式来填充 realm，但是是什么时候给你 <code>Authenticator</code> 填充 realm 的呢？<br>通过debug才发现，<code>AuthenticatingSecurityManager</code> 重写了父类 <code>RealmSecurityManger</code> 的 <code>afterRealmsSet()</code> 方法，在里面给 <code>authenticator</code> 填充了 realms </p>
<pre><code class="java">    // line 90
    /**
     * Passes on the {@link #getRealms() realms} to the internal delegate &lt;code&gt;Authenticator&lt;/code&gt; instance so
     * that it may use them during authentication attempts.
     */
    protected void afterRealmsSet() {
        super.afterRealmsSet();
        if (this.authenticator instanceof ModularRealmAuthenticator) {
            ((ModularRealmAuthenticator) this.authenticator).setRealms(getRealms());
        }
    }</code></pre>

    </div>
</article>
</main>
</div>
</body>
</html>